use std::collections::HashSet;
use std::fmt;

#[derive(Debug, PartialEq, Clone)]
pub struct Expression<'a> {
    pub minute: &'a str,
    pub hour: &'a str,
    pub date: &'a str,
    pub day: &'a str,
    pub month: &'a str,
    pub command: &'a str,
}

impl<'a> fmt::Display for Expression<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{} {} {} {} {} {}",
            self.minute, self.hour, self.date, self.day, self.month, self.command
        )
    }
}

impl<'a> Expression<'a> {
    /// Returns a Expression
    ///
    /// # Examples
    ///
    /// ```
    /// use cron_gate::expression::Expression;
    ///
    /// let e = Expression::new("* * * ? * command");
    /// assert_eq!(e, Expression {
    ///   minute: "*",
    ///   hour: "*",
    ///   date: "*",
    ///   month: "?",
    ///   day: "*",
    ///   command: "command",
    /// });
    /// ```
    pub fn new(expression_str: &str) -> Expression {
        let spw: Vec<&str> = expression_str.split_whitespace().collect();
        if spw.len() != 6 {
            panic!("Invalid expression.")
        }
        Expression {
            minute: spw[0],
            hour: spw[1],
            date: spw[2],
            month: spw[3],
            day: spw[4],
            command: spw[5],
        }
    }
}

/// # Examples
/// ```
/// use cron_gate::expression;
///
/// let v = expression::parse_minute("1,2,30").unwrap();
/// assert_eq!(v, vec![1, 2, 30]);
/// ```
pub fn parse_minute(minute: &str) -> Result<Vec<i8>, String> {
    let mut minutes: Vec<i8> = Vec::new();
    let units = minute.split(',');
    for u in units {
        match parse_unit(u) {
            Ok(mut v) => minutes.append(&mut v),
            Err(e) => return Err(format!("Invalid expression on '{}': {}", u, e)),
        };
    }
    Ok(minutes)
}

/// Returns numbers parsed from unit expression
///
/// # Examples
/// ```
/// use cron_gate::expression;
///
/// let v = expression::parse_unit("1").unwrap();
/// assert_eq!(v, vec![1]);
/// ```
pub fn parse_unit(unit: &str) -> Result<Vec<i8>, String> {
    let mut v: Vec<i8> = Vec::new();
    match unit.parse::<i8>() {
        Ok(n) => v.push(n),
        Err(_) => return Err(format!("cannot parse '{}'", unit)),
    };
    Ok(v)
}

/// Returns Vec<i8> having unique and sorted values
///
/// # Examples
/// ```
/// use cron_gate::expression;
///
/// assert_eq!(expression::uniq_and_sort(&vec![1, 1, 2, 2, 3]), vec![1, 2, 3]);
/// ```
pub fn uniq_and_sort(v: &Vec<i8>) -> Vec<i8> {
    let set: HashSet<_> = v.clone().drain(..).collect();
    let mut vec = vec![];
    vec.extend(set.into_iter());
    vec.sort_unstable();
    vec
}
